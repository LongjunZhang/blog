[{"title":"利用 Docker 缓存优化 SpringBoot 镜像构建速度","path":"/blog/2024/05/01/利用-Docker-缓存优化-SpringBoot-镜像构建速度/","content":"问题描述公司内部 CI&#x2F;CD 流程中, 从 Jenkins 所在服务器推送 SpringBoot 镜像到 Harbor 中, 这一过程非常慢, Jenkins Job 的日志中看到, 这一过程通常 30min ~ 40min (偶尔还会出现 50min 的耗时)由于开发环境会频繁修改代码, 每次构建需要等待 30min+ 十分影响开发效率, 对开发人员体验也不好. 问题分析推送速度慢, 无非是 2 个方向的原因 网速太慢 Docker 镜像太大 网速太慢经询问, 由于 Harbor 所在的服务器, 与其他服务器不在同一个网段, 且入站和出站的带宽只有 5M, 且暂时公司不考虑迁移 Jenkins 服务和 Harbor 服务到同一个内网中, 所以无法直接提升带宽解决问题. 镜像太大即使网速再快, 如果镜像动辄几百 M 甚至几个 G , 再快的网速也无济于事, 因此需要从减小镜像体积的方向来解决问题.得益于 Docker 镜像的分层缓存机制, Docker 每次 Build, Push, Pull 会充分利用已经存在的中间层镜像, 从而来大大缩短 Build, Push, Pull 的时间. 因此, 只要能重复利用缓存, 让 Docker 每次 Build, Push, Pull 只执行修改的内容, 就意味着传输的内容很小, 等同于缩小了镜像的体积.对于常见的 SpringBoot 镜像, 除了 JDK 基础镜像, 镜像的体积全都体现在 SpringBoot 应用打包之后的 Jar 包. 因此, 对于 SpringBoot 镜像, 优化的关键在于, 优化 FatJar. 方案实现以下面这个 Dockerfile 为例 1234FROM openjdk:8u92-jdk-alpineCOPY ./target/*.jar app.jarEXPOSE 8080CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;] 将其优化为下面这个方式 12345678910111213FROM openjdk:8u92-jdk-alpine AS builderCOPY ./target/*.jar app.jarEXPOSE 8080# FatJar 分层解压RUN java -Djarmode=layertools -jar app.jar extractFROM openjdk:8u92-jdk-alpine# FatJar 分层构建镜像COPY --from=builder dependencies/ ./COPY --from=builder spring-boot-loader/ ./COPY --from=builder snapshot-dependencies/ ./COPY --from=builder application/ ./ENTRYPOINT [&quot;java&quot;, &quot;org.springframework.boot.loader.JarLauncher&quot;] 优化之后, Docker 每次 Build, Push, Pull 只会变更application/层的代码.经实际使用后发现, 每次 CI&#x2F;CD 流程时间缩短为 2~3min, 效果显著! 技术原理分层机制Docker 的分层机制基于 Docker 镜像分层结构的特点, 因此, 对于越是不怎么需要变更的内容, 应该放到越底层; 对于频繁修改的内容, 需要放到顶层.为了避免缓存失效的问题, 我们应该按照内容变更频繁来决定 Layer 的排列顺序, 不能乱排; 否则后面的 Layers 都不能再被 Cache 命中. FatJar 的分层机制FatJar 内容分析FatJar 也就是通过 Maven mvn package打包成的 SpringBoot 程序, 可以直接通过java -jar app.jar命令启动.之所以叫 FatJar 是因为它将项目的所有依赖都打包进去了, 好比与传统的 War 包相比, SpringBoot 会默认将 Tomcat 容器打包进去. 这也就是为什么 SpringBoot 应用能直接启动一个 Web 应用的原因.可以将app.jar修改后缀为app.zip, 然后解压缩, 查看 Jar 包内部内容如下 其中org.springframework.boot是 SpringBoot 启动类, lib目录下便是我们的依赖 很明显, 在我们的日常开发中, 这些依赖基本也是不会变更的. 按照上述的 Docker 分层机制的特点, lib中的依赖, 应该单独作为一个 Docker Layer , 且放置到比较底层的位置. 而且lib中的 Jar 包往往比我们实际的代码classes中的代码大的多, 所以将lib单独打包成一个 Layer 会大大提升缓存的复用率. FatJar 结构拆分通过java -Djarmode=layertools -jar app.jar list我们可以看到, 类似于上面 zip 包解压的结构 dependencies依赖包 spring-boot-loaderSpringBoot 启动类 snapshot-dependencies快照依赖 application业务代码 按照变更频繁排列, 如下图 多阶段构建利用 Docker 的多阶段构建, 一共分 2 个阶段 第一阶段, 将app.jar分层解压 第二阶段, 将解压后的文件夹, 按照变更频率排列 12345678910111213FROM openjdk:8u92-jdk-alpine AS builderCOPY ./target/*.jar app.jarEXPOSE 8080# FatJar 分层解压RUN java -Djarmode=layertools -jar app.jar extractFROM openjdk:8u92-jdk-alpine# FatJar 分层构建镜像COPY --from=builder dependencies/ ./COPY --from=builder spring-boot-loader/ ./COPY --from=builder snapshot-dependencies/ ./COPY --from=builder application/ ./ENTRYPOINT [&quot;java&quot;, &quot;org.springframework.boot.loader.JarLauncher&quot;] 命令解释 AS builderbuilder 是第一阶段的命名, 是为了在第二阶段引用第一阶段的内容(也可以叫其他名称, 例如 firstStep) RUN java -Djarmode=layertools -jar app.jar extract解压 Jar 包 COPY --from=builder xx/ ./从命名为 builder 的阶段拷贝内容 ENTRYPOINT [&quot;java&quot;, &quot;org.springframework.boot.loader.JarLauncher&quot;]SpringBoot 启动类的命令 扩展以上优化应用容器的优化思路, 不仅仅可以用在 SpringBoot 中, 很多需要依赖大量第三方组件的应用容器, 也可以这样优化. 例如, 前端项目npm run build会下载大量第三方组件, 这些组件可以作为容器的底层缓存起来, 这样就可以避免重复构建."},{"title":"Hello World","path":"/blog/2024/05/01/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]